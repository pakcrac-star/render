<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=no">
    <title>Apex Overload Core (Fluid and Fixed)</title>
    <script src="https://cdn.tailwindcss.com"></script>
    <link href="https://fonts.googleapis.com/css2?family=Orbitron:wght@400;700&display=swap" rel="stylesheet">
    <style>
        /* Base styles */
        body {
            background: #000;
            color: #d0d0d0;
            font-family: 'Orbitron', sans-serif;
            overflow: hidden;
            margin: 0;
        }
        /* Canvas layers */
        canvas {
            position: absolute;
            top: 0; left: 0;
            width: 100vw;
            height: 100vh;
        }
        /* CPU Canvas uses screen blend mode for the cosmic effect */
        #gpu-canvas { z-index: 1; }
        #cpu-canvas { z-index: 2; pointer-events: none; mix-blend-mode: screen; } 
        
        /* UI and Glassmorphism */
        #ui-layer {
            position: absolute;
            z-index: 10;
            top: 0; left: 0; right: 0; bottom: 0;
            pointer-events: none;
            display: flex;
            flex-direction: column;
            justify-content: space-between;
            padding: 1.5rem;
        }
        .glass-panel {
            background: rgba(10, 10, 15, 0.85);
            backdrop-filter: blur(20px);
            -webkit-backdrop-filter: blur(20px);
            border: 1px solid rgba(255, 255, 255, 0.08);
            box-shadow: 0 0 50px rgba(70, 70, 200, 0.1);
            pointer-events: auto;
            border-radius: 1.5rem;
        }
        /* Metric display */
        .metric-value {
            text-shadow: 0 0 15px currentColor;
            font-feature-settings: "tnum";
            font-variant-numeric: tabular-nums;
        }
        .pulse-text {
            animation: pulse-glow 1.5s infinite alternate;
        }
        @keyframes pulse-glow {
            0% { box-shadow: 0 0 10px rgba(255, 20, 147, 0.5); opacity: 0.8; }
            100% { box-shadow: 0 0 20px rgba(255, 20, 147, 0.9); opacity: 1.0; }
        }
        .button-glow:hover {
            box-shadow: 0 0 20px currentColor;
        }
        .error-message {
            background-color: rgba(255, 0, 0, 0.2);
            color: #ffaaaa;
            border: 1px solid #ff0000;
            padding: 0.5rem;
            border-radius: 0.5rem;
        }
    </style>
</head>
<body>

    <canvas id="gpu-canvas"></canvas>
    <canvas id="cpu-canvas"></canvas>

    <div id="ui-layer">
        <!-- Stats Panel -->
        <div class="flex justify-between items-start">
            <div class="glass-panel p-8 w-80 border-t-4 border-pink-500 shadow-xl">
                <h1 class="text-3xl font-bold text-white mb-2 tracking-wider">APEX <span class="text-pink-500">LOAD</span></h1>
                <p class="text-xs text-gray-400 uppercase tracking-widest mb-6">Extreme Hardware Stress Test</p>
                
                <div class="space-y-6">
                    <div class="flex justify-between items-end border-b border-gray-700 pb-2">
                        <div class="text-sm text-blue-400 font-extrabold uppercase">GPU Render (Fluid)</div>
                        <div id="gpu-val" class="metric-value text-4xl font-bold text-blue-400">0 <span class="text-sm text-gray-500">FPS</span></div>
                    </div>
                    <div class="flex justify-between items-end border-b border-gray-700 pb-2">
                        <div class="text-sm text-orange-400 font-extrabold uppercase">CPU Unit Score (Fixed Load)</div>
                        <div id="cpu-val" class="metric-value text-4xl font-bold text-orange-400">0 <span class="text-sm text-gray-500">OPS/S</span></div>
                    </div>
                    <div class="flex justify-between items-end">
                        <div class="text-sm text-purple-400 font-extrabold uppercase">Hybrid Overall View</div>
                        <div id="hybrid-val" class="metric-value text-4xl font-bold text-purple-400">0.0 <span class="text-sm text-gray-500">INDEX</span></div>
                    </div>
                </div>
                
                <div id="status-msg" class="mt-6 text-sm text-center text-gray-500 pulse-text p-2 rounded-lg">SYSTEM IDLE</div>
                <div id="error-msg" class="mt-4 text-xs error-message hidden"></div>
            </div>
        </div>

        <!-- Control Deck -->
        <div class="flex justify-center pb-8">
            <div class="glass-panel p-3 flex gap-4">
                <button onclick="setMode('GPU')" class="px-7 py-4 rounded-full bg-blue-900/40 border border-blue-700 text-blue-300 font-bold hover:bg-blue-600 transition-all button-glow">
                    GPU FLUID
                </button>
                <button onclick="setMode('CPU')" class="px-7 py-4 rounded-full bg-orange-900/40 border border-orange-700 text-orange-300 font-bold hover:bg-orange-600 transition-all button-glow">
                    CPU NEBULA
                </button>
                <button onclick="setMode('HYBRID')" class="px-7 py-4 rounded-full bg-purple-900/40 border border-purple-700 text-purple-300 font-bold hover:bg-purple-600 transition-all button-glow">
                    HYBRID VOLUMETRIC
                </button>
                <div class="w-px bg-gray-700 mx-2"></div>
                <button onclick="setMode('STOP')" class="px-7 py-4 rounded-full bg-red-900/20 border border-red-900 text-red-400 font-bold hover:bg-red-600 hover:text-white transition-all">
                    TERMINATE
                </button>
            </div>
        </div>
    </div>

<script>
    // --- ENGINE CONFIGURATION & STATE ---
    const ENGINE = {
        zoom: 3.5,
        rotY: 0.0,
        particles: 5000, 
        mouse: { x: 0, y: 0, down: 0, dx: 0, dy: 0 },
        screen: { w: 0, h: 0 },
        volumetricLight: { x: 0.0, y: 0.0, z: 0.0 } 
    };

    let activeMode = 'STOP';
    let gpuReq, cpuInterval;
    let lastTime = performance.now();
    let frames = 0;
    
    // CPU Performance Tracking for Fixed Score
    const CPU_BASELINE_FRAMES = 100;
    let cpuOpsCount = 0;
    let cpuOpsTotal = 0;
    let cpuTimeTotal = 0;
    let finalCpuScore = 0; // Stores the fixed OPS/S score

    // --- 1. GPU APEX KERNEL (GLSL) - Enhanced for Fluid Dancing ---
    const canvasGL = document.getElementById('gpu-canvas');
    const gl = canvasGL.getContext('webgl');

    if (!gl) {
        // ... (Error handling remains unchanged)
        const errorMsgElement = document.getElementById('error-msg');
        errorMsgElement.innerText = "Error: WebGL context failed to initialize. GPU rendering is disabled. Try enabling CPU mode.";
        errorMsgElement.classList.remove('hidden');
        console.error("WebGL initialization failed.");
        document.querySelector('button[onclick=\"setMode(\'GPU\')\"]').disabled = true;
        document.querySelector('button[onclick=\"setMode(\'HYBRID\')\"]').disabled = true;
    }

    const VS = `attribute vec4 p; void main(){gl_Position=p;}`;
    
    // --- START OF GLSL FRAGMENT SHADER (FS) - Fluid Dynamics and Bioluminescence ---
    const FS = `
    precision highp float;
    uniform vec2 u_res;
    uniform float u_time;
    uniform vec3 u_cam;
    uniform vec2 u_mouse;
    uniform float u_click;
    uniform vec3 u_vLight;

    // FBM Noise & Worley 
    vec3 hash3(vec3 p) {
        p = fract(p * vec3(443.897, 441.423, 437.195));
        p += dot(p, p.zxy + 19.23);
        return fract(vec3(p.x * p.y, p.z * p.x, p.y * p.z));
    }
    float noise(vec3 p) {
        vec3 i = floor(p);
        vec3 f = fract(p);
        vec3 u = f * f * (3.0 - 2.0 * f);
        float a = dot(hash3(i + vec3(0,0,0)), f - vec3(0,0,0));
        float b = dot(hash3(i + vec3(1,0,0)), f - vec3(1,0,0));
        float c = dot(hash3(i + vec3(0,1,0)), f - vec3(0,1,0));
        float d = dot(hash3(i + vec3(1,1,0)), f - vec3(1,1,0));
        float e = dot(hash3(i + vec3(0,0,1)), f - vec3(0,0,1));
        float g = dot(hash3(i + vec3(1,0,1)), f - vec3(1,0,1));
        float h = dot(hash3(i + vec3(0,1,1)), f - vec3(0,1,1));
        float k = dot(hash3(i + vec3(1,1,1)), f - vec3(1,1,1));
        return mix(mix(mix(a, b, u.x), mix(c, d, u.x), u.y), mix(mix(e, g, u.x), mix(h, k, u.x), u.y), u.z);
    }
    float fbm(vec3 p) { 
        float f = 0.0;
        f += 0.5000 * noise(p); p *= 2.02;
        f += 0.2500 * noise(p); p *= 2.03;
        f += 0.1250 * noise(p); p *= 2.01;
        f += 0.0625 * noise(p);
        return f;
    }
    
    // Utility functions for rotation and smooth blending
    mat2 rot(float a) { float s=sin(a), c=cos(a); return mat2(c,-s,s,c); }
    float smin(float a, float b, float k) { float h = clamp(0.5 + 0.5 * (b - a) / k, 0.0, 1.0); return mix(b, a, h) - k * h * (1.0 - h); }

    // --- GPU Aesthetic Upgrade: Highly Dynamic Fluid Dancing ---
    vec3 fluidWarp(vec3 p) {
        float time_factor = u_time * 0.5;
        
        // Complex, time-based rotational and scaling distortion
        p.xy *= rot(sin(time_factor * 0.1) * 0.5); 
        p.yz *= rot(cos(time_factor * 0.15) * 0.7);

        // Core pulsating noise distortion
        float distortion = fbm(p * 2.5 + time_factor * 0.2) * 0.5;
        p += distortion * vec3(0.5, 0.0, 0.5);

        // Mouse interaction for localized fluid ripples
        if(u_click > 0.5) {
            vec2 m = (u_mouse - 0.5) * 4.0; 
            m.y *= -1.0;
            float d = length(p.xy - m) + 0.1;
            float ripple = sin(d * 30.0 - u_time * 15.0) * exp(-d * 4.0);
            p.z += ripple * 0.8; // Stronger Z-ripple
        }
        return p;
    }

    // High-complexity Peony SDF (Bioluminescent Structure)
    float map(vec3 p) {
        p = fluidWarp(p);
        p.xz *= rot(p.y * 0.3 + u_time * 0.1);

        float r = length(p);
        float a = atan(p.z, p.x);
        
        float d = r - 1.0;

        // Petal Structure Modulation
        float waves = sin(a*15.0 + p.y*20.0) * sin(p.y*4.0 + u_time*0.3);
        float roughness = fbm(p * 6.0 + u_time * 0.5) * 0.1;
        float cup = smoothstep(-1.0, 0.5, p.y);
        
        d += (waves * 0.3 * cup) + roughness;

        float inner = length(p + vec3(0,0.5,0)) - 0.5;
        d = smin(d, inner, 0.2);

        return d * 0.6;
    }

    // --- RAYMARCHING & SHADING ---
    void main() {
        vec2 uv = (gl_FragCoord.xy - 0.5 * u_res) / u_res.y;
        
        vec3 ro = u_cam;
        vec3 ta = vec3(0, -0.2, 0);
        vec3 fwd = normalize(ta - ro);
        vec3 right = normalize(cross(fwd, vec3(0,1,0)));
        vec3 up = cross(right, fwd);
        vec3 rd = normalize(fwd + uv.x*right + uv.y*up);

        float t = 0.0, d = 0.0;
        
        // Extreme Raymarching Loop (256 steps)
        for(int i=0; i<256; i++) { 
            vec3 p = ro + rd * t;
            d = map(p);
            if(d<0.0001 || t>12.0) break;
            t += d * 0.6; 
        }

        vec3 col = vec3(0.0);
        
        if(t < 12.0) {
            vec3 p = ro + rd * t;
            vec2 e = vec2(0.001, 0);
            vec3 n = normalize(vec3(map(p+e.xyy)-map(p-e.xyy), map(p+e.yxy)-map(p-e.yxy), map(p+e.yyx)-map(p-e.yyx)));
            
            vec3 lig = u_vLight; 
            if(length(u_vLight) < 0.1) { 
                lig = normalize(vec3(sin(u_time*0.5), 1.0, cos(u_time*0.5)));
            }

            float LdotN = max(dot(n, lig), 0.0);
            vec3 halfVec = normalize(lig - rd);
            
            // Bioluminescent Color Pallette (Increased Intensity)
            float r = length(p);
            
            vec3 albedo = mix(vec3(0.0, 0.8, 1.0), vec3(1.0, 0.0, 1.0), smoothstep(0.5, 2.0, r)); // More vivid cyan/magenta
            
            float fresnel = pow(1.0 - max(0.0, dot(-n, rd)), 8.0) * 2.0; // Sharper, stronger Fresnel
            float sss = pow(max(0.0, dot(-lig, rd)), 4.0) * 1.5; 
            float spec = pow(max(0.0, dot(n, halfVec)), 200.0) * 2.0; // Pin-sharp, intense specular
            
            col = albedo * (LdotN * 0.7 + 0.15) 
                  + albedo * sss * 1.5 // Max translucency boost
                  + vec3(1.0) * spec * 1.5 // Bright specular
                  + vec3(0.7, 0.9, 1.0) * fresnel * 1.0; 

            // Volumetric Light Scattering / Fog
            float t_norm = t / 10.0;
            float lightScatter = max(0.0, dot(lig, -rd)) * 0.5 * exp(-t_norm * 1.5);
            col += vec3(0.0, 0.7, 1.0) * lightScatter * 3.0; // Max light scatter

            // Fluid Interaction Glow
            if(u_click > 0.5) {
                float distToMouseRay = length(uv - (u_mouse - 0.5) * vec2(u_res.x/u_res.y, 1.0));
                col += vec3(0.5, 1.0, 1.0) * exp(-distToMouseRay * 10.0) * 1.5; 
            }
            
            col = mix(col, vec3(0.0), 1.0 - exp(-0.015 * t*t));
        }

        gl_FragColor = vec4(col, 1.0);
    }`;
    // --- END OF GLSL FRAGMENT SHADER (FS) ---

    // --- WebGL Initialization ---
    let prog, uRes, uTime, uCam, uMouse, uClick, uVLight;
    
    if (gl) {
        // ... (WebGL initialization functions remain unchanged)
        function createProg(gl, vs, fs) {
            const p = gl.createProgram();
            const v = gl.createShader(gl.VERTEX_SHADER); gl.shaderSource(v, vs); gl.compileShader(v);
            const f = gl.createShader(gl.FRAGMENT_SHADER); gl.shaderSource(f, fs); gl.compileShader(f);
            if(!gl.getShaderParameter(f, gl.COMPILE_STATUS)) {
                console.error("Shader Compile Error:", gl.getShaderInfoLog(f));
                return null;
            }
            gl.attachShader(p, v); gl.attachShader(p, f); gl.linkProgram(p);
            return p;
        }

        prog = createProg(gl, VS, FS);

        if (prog) {
            const buf = gl.createBuffer();
            gl.bindBuffer(gl.ARRAY_BUFFER, buf);
            gl.bufferData(gl.ARRAY_BUFFER, new Float32Array([-1,-1, 1,-1, -1,1, -1,1, 1,-1, 1,1]), gl.STATIC_DRAW);
            const loc = gl.getAttribLocation(prog, 'p');
            gl.enableVertexAttribArray(loc);
            gl.vertexAttribPointer(loc, 2, gl.FLOAT, false, 0, 0);

            uRes = gl.getUniformLocation(prog, 'u_res');
            uTime = gl.getUniformLocation(prog, 'u_time');
            uCam = gl.getUniformLocation(prog, 'u_cam');
            uMouse = gl.getUniformLocation(prog, 'u_mouse');
            uClick = gl.getUniformLocation(prog, 'u_click');
            uVLight = gl.getUniformLocation(prog, 'u_vLight');
        } else {
            document.getElementById('error-msg').innerText = "Error: GLSL program failed to link. Check console for shader errors.";
            document.getElementById('error-msg').classList.remove('hidden');
        }
    }


    // --- 2. CPU PHYSICS ENGINE (Nebula Forge) ---
    const ctx = document.getElementById('cpu-canvas').getContext('2d');
    let bodies = [];
    const G = 0.05; 
    const K_STRESS = 0.5; 

    function initBodies() {
        bodies = [];
        // Reset CPU score counters upon initialization
        cpuOpsCount = 0;
        cpuOpsTotal = 0;
        cpuTimeTotal = 0;
        finalCpuScore = 0; 

        const w = window.innerWidth;
        const h = window.innerHeight;
        for(let i=0; i<ENGINE.particles; i++) {
            const hue = (i * 360 / ENGINE.particles) % 360;
            bodies.push({
                x: Math.random() * w,
                y: Math.random() * h,
                vx: (Math.random()-0.5)*1.0, 
                vy: (Math.random()-0.5)*1.0,
                mass: Math.random() * 2 + 1, 
                color: `hsl(${hue}, 80%, 70%)` 
            });
        }
    }

    // O(N^2) Physics 
    function updatePhysics() {
        let ops = 0;
        const count = bodies.length;
        const centerX = ENGINE.screen.w / 2;
        const centerY = ENGINE.screen.h / 2;
        
        let totalMomentumX = 0;
        let totalMomentumY = 0;

        for(let i=0; i<count; i++) {
            let p1 = bodies[i];
            
            // Per-Particle Stress Field Calculation
            let dxC = p1.x - centerX;
            let dyC = p1.y - centerY;
            let distC = Math.sqrt(dxC*dxC + dyC*dyC);
            
            let stressForce = K_STRESS * Math.sin(p1.x * 0.005) * Math.cos(p1.y * 0.005) * 0.5;
            p1.vx += stressForce * dxC / (distC + 1) * 0.01;
            p1.vy += stressForce * dyC / (distC + 1) * 0.01;
            ops += 5; 

            // N-Body interaction
            for(let j=i+1; j<count; j++) { 
                let p2 = bodies[j];
                let dx = p2.x - p1.x;
                let dy = p2.y - p1.y;
                let distSq = dx*dx + dy*dy + 200; 
                let dist = Math.sqrt(distSq);
                let force = (p1.mass * p2.mass * G) / distSq;
                
                let fx = (dx / dist) * force;
                let fy = (dy / dist) * force;
                
                p1.vx += fx / p1.mass;
                p1.vy += fy / p1.mass;
                p2.vx -= fx / p2.mass;
                p2.vy -= fy / p2.mass;
                
                ops++; 
            }
            
            // Integration, Damping, and Boundary Wrap
            p1.x += p1.vx;
            p1.y += p1.vy;
            p1.vx *= 0.99;
            p1.vy *= 0.99;

            if (p1.x < 0) p1.x += ENGINE.screen.w;
            if (p1.x > ENGINE.screen.w) p1.x -= ENGINE.screen.w;
            if (p1.y < 0) p1.y += ENGINE.screen.h;
            if (p1.y > ENGINE.screen.h) p1.y -= ENGINE.screen.h;
            
            totalMomentumX += p1.vx * p1.mass;
            totalMomentumY += p1.vy * p1.mass;
        }

        // Update the Global Light Vector (Hybrid Link)
        if (activeMode === 'HYBRID') {
            const avgVX = totalMomentumX / count;
            const avgVY = totalMomentumY / count;
            ENGINE.volumetricLight.x = avgVX * 0.5;
            ENGINE.volumetricLight.y = -0.5; 
            ENGINE.volumetricLight.z = avgVY * 0.5;
            
            const len = Math.sqrt(ENGINE.volumetricLight.x**2 + ENGINE.volumetricLight.y**2 + ENGINE.volumetricLight.z**2);
            if (len > 0) {
                 ENGINE.volumetricLight.x /= len;
                 ENGINE.volumetricLight.y /= len;
                 ENGINE.volumetricLight.z /= len;
            }
        } else {
             ENGINE.volumetricLight = { x: 0.0, y: 0.0, z: 0.0 };
        }

        return ops;
    }

    function renderCPU() {
        // Clear with a very light trail (creating the nebula effect)
        ctx.fillStyle = activeMode === 'HYBRID' ? 'rgba(0, 0, 0, 0.05)' : 'rgba(0, 0, 0, 0.1)';
        ctx.fillRect(0,0,ENGINE.screen.w, ENGINE.screen.h);
        
        ctx.globalCompositeOperation = 'lighter';
        
        // Particle Drawing (Beautiful Star Field)
        for(let p of bodies) {
            ctx.fillStyle = p.color;
            ctx.beginPath();
            ctx.arc(p.x, p.y, p.mass, 0, 2 * Math.PI); 
            ctx.fill();
        }
        
        ctx.globalCompositeOperation = 'source-over';
    }

    // --- LOOPS ---

    function loopGPU(t) {
        if(activeMode !== 'GPU' && activeMode !== 'HYBRID' || !gl || !prog) return;
        gpuReq = requestAnimationFrame(loopGPU);

        ENGINE.rotY += 0.003;
        let camX = Math.sin(ENGINE.rotY) * ENGINE.zoom;
        let camZ = Math.cos(ENGINE.rotY) * ENGINE.zoom;

        const mx = ENGINE.mouse.x / window.innerWidth;
        const my = ENGINE.mouse.y / window.innerHeight;

        gl.useProgram(prog);
        gl.uniform2f(uRes, window.innerWidth, window.innerHeight);
        gl.uniform1f(uTime, t*0.001);
        gl.uniform3f(uCam, camX, 1.5, camZ);
        gl.uniform2f(uMouse, mx, my);
        gl.uniform1f(uClick, ENGINE.mouse.down);
        gl.uniform3f(uVLight, ENGINE.volumetricLight.x, ENGINE.volumetricLight.y, 

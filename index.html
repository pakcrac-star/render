<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=no">
    <title>Apex Overload Core (Aesthetic Refactor)</title>
    <script src="https://cdn.tailwindcss.com"></script>
    <link href="https://fonts.googleapis.com/css2?family=Orbitron:wght@400;700&display=swap" rel="stylesheet">
    <style>
        /* Base styles */
        body {
            background: #000;
            color: #d0d0d0;
            font-family: 'Orbitron', sans-serif;
            overflow: hidden;
            margin: 0;
        }
        /* Canvas layers */
        canvas {
            position: absolute;
            top: 0; left: 0;
            width: 100vw;
            height: 100vh;
        }
        /* CPU Canvas uses screen blend mode for the cosmic effect */
        #gpu-canvas { z-index: 1; }
        #cpu-canvas { z-index: 2; pointer-events: none; mix-blend-mode: screen; } 
        
        /* UI and Glassmorphism */
        #ui-layer {
            position: absolute;
            z-index: 10;
            top: 0; left: 0; right: 0; bottom: 0;
            pointer-events: none;
            display: flex;
            flex-direction: column;
            justify-content: space-between;
            padding: 1.5rem;
        }
        .glass-panel {
            background: rgba(10, 10, 15, 0.85);
            backdrop-filter: blur(20px);
            -webkit-backdrop-filter: blur(20px);
            border: 1px solid rgba(255, 255, 255, 0.08);
            box-shadow: 0 0 50px rgba(70, 70, 200, 0.1);
            pointer-events: auto;
            border-radius: 1.5rem;
        }
        /* Metric display */
        .metric-value {
            text-shadow: 0 0 15px currentColor;
            font-feature-settings: "tnum";
            font-variant-numeric: tabular-nums;
        }
        .pulse-text {
            animation: pulse-glow 1.5s infinite alternate;
        }
        @keyframes pulse-glow {
            0% { box-shadow: 0 0 10px rgba(255, 20, 147, 0.5); opacity: 0.8; }
            100% { box-shadow: 0 0 20px rgba(255, 20, 147, 0.9); opacity: 1.0; }
        }
        .button-glow:hover {
            box-shadow: 0 0 20px currentColor;
        }
        .error-message {
            background-color: rgba(255, 0, 0, 0.2);
            color: #ffaaaa;
            border: 1px solid #ff0000;
            padding: 0.5rem;
            border-radius: 0.5rem;
        }
    </style>
</head>
<body>

    <canvas id="gpu-canvas"></canvas>
    <canvas id="cpu-canvas"></canvas>

    <div id="ui-layer">
        <div class="flex justify-between items-start">
            <div class="glass-panel p-8 w-80 border-t-4 border-pink-500 shadow-xl">
                <h1 class="text-3xl font-bold text-white mb-2 tracking-wider">APEX <span class="text-pink-500">LOAD</span></h1>
                <p class="text-xs text-gray-400 uppercase tracking-widest mb-6">Extreme Hardware Stress Test</p>
                
                <div class="space-y-6">
                    <div class="flex justify-between items-end border-b border-gray-700 pb-2">
                        <div class="text-sm text-blue-400 font-extrabold uppercase">GPU Render (Luminance)</div>
                        <div id="gpu-val" class="metric-value text-4xl font-bold text-blue-400">0 <span class="text-sm text-gray-500">FPS</span></div>
                    </div>
                    <div class="flex justify-between items-end border-b border-gray-700 pb-2">
                        <div class="text-sm text-orange-400 font-extrabold uppercase">CPU Unit Score (Nebula Forge)</div>
                        <div id="cpu-val" class="metric-value text-4xl font-bold text-orange-400">0 <span class="text-sm text-gray-500">OPS/S</span></div>
                    </div>
                    <div class="flex justify-between items-end">
                        <div class="text-sm text-purple-400 font-extrabold uppercase">Hybrid Overall View</div>
                        <div id="hybrid-val" class="metric-value text-4xl font-bold text-purple-400">0.0 <span class="text-sm text-gray-500">INDEX</span></div>
                    </div>
                </div>
                
                <div id="status-msg" class="mt-6 text-sm text-center text-gray-500 pulse-text p-2 rounded-lg">SYSTEM IDLE</div>
                <div id="error-msg" class="mt-4 text-xs error-message hidden"></div>
            </div>
        </div>

        <div class="flex justify-center pb-8">
            <div class="glass-panel p-3 flex gap-4">
                <button onclick="setMode('GPU')" class="px-7 py-4 rounded-full bg-blue-900/40 border border-blue-700 text-blue-300 font-bold hover:bg-blue-600 transition-all button-glow">
                    GPU LUMINANCE
                </button>
                <button onclick="setMode('CPU')" class="px-7 py-4 rounded-full bg-orange-900/40 border border-orange-700 text-orange-300 font-bold hover:bg-orange-600 transition-all button-glow">
                    CPU NEBULA
                </button>
                <button onclick="setMode('HYBRID')" class="px-7 py-4 rounded-full bg-purple-900/40 border border-purple-700 text-purple-300 font-bold hover:bg-purple-600 transition-all button-glow">
                    HYBRID VOLUMETRIC
                </button>
                <div class="w-px bg-gray-700 mx-2"></div>
                <button onclick="setMode('STOP')" class="px-7 py-4 rounded-full bg-red-900/20 border border-red-900 text-red-400 font-bold hover:bg-red-600 hover:text-white transition-all">
                    TERMINATE
                </button>
            </div>
        </div>
    </div>

<script>
    // --- ENGINE CONFIGURATION & STATE ---
    const ENGINE = {
        zoom: 3.5,
        rotY: 0.0,
        particles: 5000, // Reduced for CPU performance
        mouse: { x: 0, y: 0, down: 0, dx: 0, dy: 0 },
        screen: { w: 0, h: 0 },
        volumetricLight: { x: 0.0, y: 0.0, z: 0.0 } 
    };

    let activeMode = 'STOP';
    let gpuReq, cpuInterval;
    let lastTime = performance.now();
    let frames = 0;
    
    // --- 1. GPU APEX KERNEL (GLSL) - Enhanced for Bioluminescence ---
    const canvasGL = document.getElementById('gpu-canvas');
    const gl = canvasGL.getContext('webgl');

    if (!gl) {
        const errorMsgElement = document.getElementById('error-msg');
        errorMsgElement.innerText = "Error: WebGL context failed to initialize. GPU rendering is disabled. Try enabling CPU mode.";
        errorMsgElement.classList.remove('hidden');
        console.error("WebGL initialization failed.");
        document.querySelector('button[onclick="setMode(\'GPU\')"]').disabled = true;
        document.querySelector('button[onclick="setMode(\'HYBRID\')"]').disabled = true;
    }

    const VS = `attribute vec4 p; void main(){gl_Position=p;}`;
    
    // --- START OF GLSL FRAGMENT SHADER (FS) - Highly Aesthetic, Complex Code ---
    const FS = `
    precision highp float;
    uniform vec2 u_res;
    uniform float u_time;
    uniform vec3 u_cam;
    uniform vec2 u_mouse;
    uniform float u_click;
    uniform vec3 u_vLight;

    // FBM Noise & Worley - Essential for the complex organic look
    vec3 hash3(vec3 p) {
        p = fract(p * vec3(443.897, 441.423, 437.195));
        p += dot(p, p.zxy + 19.23);
        return fract(vec3(p.x * p.y, p.z * p.x, p.y * p.z));
    }
    float noise(vec3 p) {
        vec3 i = floor(p);
        vec3 f = fract(p);
        vec3 u = f * f * (3.0 - 2.0 * f);
        float a = dot(hash3(i + vec3(0,0,0)), f - vec3(0,0,0));
        float b = dot(hash3(i + vec3(1,0,0)), f - vec3(1,0,0));
        float c = dot(hash3(i + vec3(0,1,0)), f - vec3(0,1,0));
        float d = dot(hash3(i + vec3(1,1,0)), f - vec3(1,1,0));
        float e = dot(hash3(i + vec3(0,0,1)), f - vec3(0,0,1));
        float g = dot(hash3(i + vec3(1,0,1)), f - vec3(1,0,1));
        float h = dot(hash3(i + vec3(0,1,1)), f - vec3(0,1,1));
        float k = dot(hash3(i + vec3(1,1,1)), f - vec3(1,1,1));
        return mix(mix(mix(a, b, u.x), mix(c, d, u.x), u.y), mix(mix(e, g, u.x), mix(h, k, u.x), u.y), u.z);
    }
    float fbm(vec3 p) { 
        float f = 0.0;
        f += 0.5000 * noise(p); p *= 2.02;
        f += 0.2500 * noise(p); p *= 2.03;
        f += 0.1250 * noise(p); p *= 2.01;
        f += 0.0625 * noise(p);
        return f;
    }
    
    // Utility functions for rotation and smooth blending
    mat2 rot(float a) { float s=sin(a), c=cos(a); return mat2(c,-s,s,c); }
    float smin(float a, float b, float k) { float h = clamp(0.5 + 0.5 * (b - a) / k, 0.0, 1.0); return mix(b, a, h) - k * h * (1.0 - h); }

    // Fluid Interaction (Mouse Click)
    vec3 fluidWarp(vec3 p) {
        if(u_click > 0.5) {
            vec2 m = (u_mouse - 0.5) * 4.0; 
            m.y *= -1.0;
            float d = length(p.xy - m) + 0.1;
            float ripple = sin(d * 25.0 - u_time * 10.0) * exp(-d * 3.0);
            p.z += ripple * 0.5; 
        }
        return p;
    }

    // High-complexity Peony SDF (Bioluminescent Structure)
    float map(vec3 p) {
        p = fluidWarp(p);
        p.xz *= rot(p.y * 0.3 + u_time * 0.1);

        float r = length(p);
        float a = atan(p.z, p.x);
        
        float d = r - 1.0;

        // Petal Structure Modulation
        float waves = sin(a*15.0 + p.y*20.0) * sin(p.y*4.0 + u_time*0.3);
        
        // FBM & Ruffling for organic texture (Slightly reduced scale for cleaner look)
        float roughness = fbm(p * 6.0 + u_time * 0.5) * 0.1;
        
        float cup = smoothstep(-1.0, 0.5, p.y);
        
        d += (waves * 0.3 * cup) + roughness;

        float inner = length(p + vec3(0,0.5,0)) - 0.5;
        d = smin(d, inner, 0.2);

        return d * 0.6;
    }

    // --- RAYMARCHING & SHADING ---
    void main() {
        vec2 uv = (gl_FragCoord.xy - 0.5 * u_res) / u_res.y;
        
        vec3 ro = u_cam;
        vec3 ta = vec3(0, -0.2, 0);
        vec3 fwd = normalize(ta - ro);
        vec3 right = normalize(cross(fwd, vec3(0,1,0)));
        vec3 up = cross(right, fwd);
        vec3 rd = normalize(fwd + uv.x*right + uv.y*up);

        float t = 0.0, d = 0.0;
        
        // Extreme Raymarching Loop (256 steps)
        for(int i=0; i<256; i++) { 
            vec3 p = ro + rd * t;
            d = map(p);
            if(d<0.0001 || t>12.0) break;
            t += d * 0.6; 
        }

        vec3 col = vec3(0.0);
        
        if(t < 12.0) {
            vec3 p = ro + rd * t;
            vec2 e = vec2(0.001, 0);
            vec3 n = normalize(vec3(map(p+e.xyy)-map(p-e.xyy), map(p+e.yxy)-map(p-e.yxy), map(p+e.yyx)-map(p-e.yyx)));
            
            vec3 lig = u_vLight; 
            if(length(u_vLight) < 0.1) { 
                lig = normalize(vec3(sin(u_time*0.5), 1.0, cos(u_time*0.5)));
            }

            float LdotN = max(dot(n, lig), 0.0);
            vec3 halfVec = normalize(lig - rd);
            
            // --- Aesthetic Upgrade: Bioluminescent Color Pallette ---
            float r = length(p);
            
            // Base color: Fade from Cyan (inner) to Magenta (outer)
            vec3 albedo = mix(vec3(0.1, 0.8, 1.0), vec3(0.9, 0.2, 0.9), smoothstep(0.5, 2.0, r));
            
            // Enhanced Fresnel/Reflection (Ethereal Sheen)
            float fresnel = pow(1.0 - max(0.0, dot(-n, rd)), 6.0) * 1.5; 
            
            // Subsurface Scattering (Deep Translucency)
            float sss = pow(max(0.0, dot(-lig, rd)), 4.0) * 1.5; // Stronger translucency
            
            // Specular
            float spec = pow(max(0.0, dot(n, halfVec)), 128.0) * 1.5; 
            
            col = albedo * (LdotN * 0.7 + 0.15) // Diffuse + Ambient
                  + albedo * sss * 1.0 // Translucency boost (glow from inside)
                  + vec3(1.0) * spec * 1.2 // Sharp Specular Highlight
                  + vec3(0.7, 0.9, 1.0) * fresnel * 0.8; // Blue-white edge glow

            // Volumetric Light Scattering / Fog
            float t_norm = t / 10.0;
            float lightScatter = max(0.0, dot(lig, -rd)) * 0.5 * exp(-t_norm * 1.5);
            // Scatter color: Vibrant Blue
            col += vec3(0.0, 0.5, 1.0) * lightScatter * 2.5; 

            // Fluid Interaction Glow
            if(u_click > 0.5) {
                float distToMouseRay = length(uv - (u_mouse - 0.5) * vec2(u_res.x/u_res.y, 1.0));
                col += vec3(0.5, 0.9, 1.0) * exp(-distToMouseRay * 10.0) * 1.0; // Brighter water effect
            }
            
            // Exponential Fog (Deep Space Black)
            col = mix(col, vec3(0.0), 1.0 - exp(-0.015 * t*t));
        }

        gl_FragColor = vec4(col, 1.0);
    }`;
    // --- END OF GLSL FRAGMENT SHADER (FS) ---

    // --- WebGL Initialization ---
    let prog, uRes, uTime, uCam, uMouse, uClick, uVLight;
    
    if (gl) {
        function createProg(gl, vs, fs) {
            const p = gl.createProgram();
            const v = gl.createShader(gl.VERTEX_SHADER); gl.shaderSource(v, vs); gl.compileShader(v);
            const f = gl.createShader(gl.FRAGMENT_SHADER); gl.shaderSource(f, fs); gl.compileShader(f);
            if(!gl.getShaderParameter(f, gl.COMPILE_STATUS)) {
                console.error("Shader Compile Error:", gl.getShaderInfoLog(f));
                return null;
            }
            gl.attachShader(p, v); gl.attachShader(p, f); gl.linkProgram(p);
            return p;
        }

        prog = createProg(gl, VS, FS);

        if (prog) {
            const buf = gl.createBuffer();
            gl.bindBuffer(gl.ARRAY_BUFFER, buf);
            gl.bufferData(gl.ARRAY_BUFFER, new Float32Array([-1,-1, 1,-1, -1,1, -1,1, 1,-1, 1,1]), gl.STATIC_DRAW);
            const loc = gl.getAttribLocation(prog, 'p');
            gl.enableVertexAttribArray(loc);
            gl.vertexAttribPointer(loc, 2, gl.FLOAT, false, 0, 0);

            uRes = gl.getUniformLocation(prog, 'u_res');
            uTime = gl.getUniformLocation(prog, 'u_time');
            uCam = gl.getUniformLocation(prog, 'u_cam');
            uMouse = gl.getUniformLocation(prog, 'u_mouse');
            uClick = gl.getUniformLocation(prog, 'u_click');
            uVLight = gl.getUniformLocation(prog, 'u_vLight');
        }
    }

    // --- 2. CPU NEBULA ENGINE (High Math Load) ---
    // Heavily calculates gravity between bodies.
    const ctx = document.getElementById('cpu-canvas').getContext('2d');
    let bodies = [];

    function initBodies() {
        bodies = [];
        const w = window.innerWidth;
        const h = window.innerHeight;
        // Reducing particle count for JS, but increasing calc complexity per particle
        const limit = 1200; 
        for(let i=0; i<limit; i++) {
            bodies.push({
                x: Math.random() * w,
                y: Math.random() * h,
                vx: (Math.random()-0.5)*0.5,
                vy: (Math.random()-0.5)*0.5,
                mass: Math.random() * 10 + 1,
                color: Math.random() > 0.5 ? 'rgba(255,100,200,0.8)' : 'rgba(100,200,255,0.8)'
            });
        }
    }

    // O(N^2) Physics Logic - The Stress Test
    function updatePhysics() {
        let ops = 0;
        const count = bodies.length;
        
        // The Nested Loop. If 1200 bodies, this runs 1.44 million times per frame.
        for(let i=0; i<count; i++) {
            let p1 = bodies[i];
            
            // Batch processing:
            // To ensure Hybrid mode doesn't completely freeze the UI, we only process
            // a subset of interactions if CPU load is too high, 
            // OR we process all for maximum stress.
            // Here: Maximum Stress.
            
            for(let j=0; j<count; j++) {
                if(i === j) continue;
                let p2 = bodies[j];
                
                // --- Complex Math Ops ---
                let dx = p2.x - p1.x;
                let dy = p2.y - p1.y;
                let distSq = dx*dx + dy*dy + 500; // Softening
                let dist = Math.sqrt(distSq); // Heavy op
                let force = (p1.mass * p2.mass) / distSq;
                
                // Trigonometry simulation (extra stress)
                let angle = Math.atan2(dy, dx); 
                let fx = Math.cos(angle) * force * 0.1;
                let fy = Math.sin(angle) * force * 0.1;
                
                p1.vx += fx / p1.mass;
                p1.vy += fy / p1.mass;
                
                ops++; 
            }
            
            // Integration
            p1.x += p1.vx;
            p1.y += p1.vy;
            
            // Boundary bounce
            if(p1.x < 0 || p1.x > ENGINE.screen.w) p1.vx *= -0.9;
            if(p1.y < 0 || p1.y > ENGINE.screen.h) p1.vy *= -0.9;
        }
        return ops;
    }

    function renderCPU() {
        ctx.clearRect(0,0,ENGINE.screen.w, ENGINE.screen.h);
        
        // Draw connections for visual complexity (if Hybrid)
        // Optimization: Only draw simple rects to keep bottleneck on Math, not Canvas API
        for(let p of bodies) {
            ctx.fillStyle = p.color;
            ctx.fillRect(p.x, p.y, 2, 2); 
        }
    }

    // --- LOOPS ---

    function loopGPU(t) {
        if((activeMode === 'GPU' || activeMode === 'HYBRID') && gl && prog) {
            gpuReq = requestAnimationFrame(loopGPU);

            // Orbit Camera
            ENGINE.rotY += 0.005;
            let camX = Math.sin(ENGINE.rotY) * 3.2;
            let camZ = Math.cos(ENGINE.rotY) * 3.2;

            // Update Volumetric Light pos
            ENGINE.volumetricLight.x = Math.sin(t * 0.001) * 2.0;
            ENGINE.volumetricLight.z = Math.cos(t * 0.001) * 2.0;

            const mx = ENGINE.mouse.x / window.innerWidth;
            const my = ENGINE.mouse.y / window.innerHeight;

            gl.useProgram(prog);
            gl.uniform2f(uRes, window.innerWidth, window.innerHeight);
            gl.uniform1f(uTime, t*0.001);
            gl.uniform3f(uCam, camX, 1.8, camZ); // Higher angle for flower view
            gl.uniform2f(uMouse, mx, my);
            gl.uniform1f(uClick, ENGINE.mouse.down);
            gl.uniform3f(uVLight, ENGINE.volumetricLight.x, 2.0, ENGINE.volumetricLight.z);

            gl.drawArrays(gl.TRIANGLES, 0, 6);

            // FPS Counter
            frames++;
            if(t - lastTime >= 1000) {
                document.getElementById('gpu-val').innerText = frames + " FPS";
                
                // Calculate Hybrid Score
                if(activeMode === 'HYBRID') {
                    // Extract CPU score
                    let cpuTxt = document.getElementById('cpu-val').innerText.replace(/,/g, '');
                    let cpuScore = parseInt(cpuTxt) || 0;
                    
                    // Score = (GPU FPS * 10) + (CPU Ops / 1000)
                    // Balanced so 60FPS + decent CPU = ~2000-3000 pts
                    let hybridScore = ((frames * 10) + (cpuScore / 1000000)).toFixed(2);
                    document.getElementById('hybrid-val').innerText = hybridScore;
                }
                
                frames = 0;
                lastTime = t;
            }
        }
    }

    function loopCPU() {
        if(activeMode !== 'CPU' && activeMode !== 'HYBRID') return;
        
        const start = performance.now();
        const ops = updatePhysics(); 
        renderCPU();
        const end = performance.now();
        
        const duration = end - start;
        // Estimate Ops Per Second
        // If it took 50ms to run 1.44M ops, then in 1000ms we can run (1000/50)*1.44M
        const opsPerSec = Math.floor((ops * (1000/Math.max(duration, 1))));
        
        document.getElementById('cpu-val').innerText = opsPerSec.toLocaleString();
    }

    // --- SYSTEM CONTROL ---

    function setMode(mode) {
        cancelAnimationFrame(gpuReq);
        clearInterval(cpuInterval);
        if(gl) gl.clear(gl.COLOR_BUFFER_BIT);
        ctx.clearRect(0,0,canvasGL.width, canvasGL.height);
        
        document.getElementById('gpu-val').innerText = "0 FPS";
        document.getElementById('cpu-val').innerText = "0 OPS/S";
        document.getElementById('status-msg').innerText = "SYSTEM ACTIVE: " + mode;
        
        // CSS feedback
        const statBox = document.getElementById('status-msg');
        if(mode === 'STOP') {
            statBox.className = "mt-6 text-sm text-center text-red-500 font-bold p-2";
        } else {
            statBox.className = "mt-6 text-sm text-center text-green-400 font-bold pulse-text p-2 border border-green-900 bg-green-900/20";
        }

        activeMode = mode;

        if(mode === 'GPU' || mode === 'HYBRID') {
            loopGPU(performance.now());
        }

        if(mode === 'CPU' || mode === 'HYBRID') {
            initBodies();
            // run CPU loop every 16ms, but physics calculation might take longer, causing lag (Intended Stress)
            cpuInterval = setInterval(loopCPU, 16); 
        }
    }

    // --- EVENT LISTENERS ---
    window.addEventListener('resize', () => {
        canvasGL.width = window.innerWidth;
        canvasGL.height = window.innerHeight;
        document.getElementById('cpu-canvas').width = window.innerWidth;
        document.getElementById('cpu-canvas').height = window.innerHeight;
        if(gl) gl.viewport(0,0,canvasGL.width, canvasGL.height);
        ENGINE.screen.w = window.innerWidth;
        ENGINE.screen.h = window.innerHeight;
    });
    window.dispatchEvent(new Event('resize'));

    // Interaction
    window.addEventListener('mousemove', e => {
        ENGINE.mouse.x = e.clientX;
        ENGINE.mouse.y = e.clientY;
    });
    window.addEventListener('mousedown', () => ENGINE.mouse.down = 1.0);
    window.addEventListener('mouseup', () => ENGINE.mouse.down = 0.0);
    
    // Touch support
    window.addEventListener('touchstart', (e) => {
        ENGINE.mouse.x = e.touches[0].clientX;
        ENGINE.mouse.y = e.touches[0].clientY;
        ENGINE.mouse.down = 1.0;
    });
    window.addEventListener('touchend', () => ENGINE.mouse.down = 0.0);

</script>
</body>
</html>

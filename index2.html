<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=no">
    <title>Apex Overload: Peony & Nebula</title>
    <script src="https://cdn.tailwindcss.com"></script>
    <link href="https://fonts.googleapis.com/css2?family=Rajdhani:wght@400;700&display=swap" rel="stylesheet">
    <style>
        /* Base styles */
        body {
            background: #050505;
            color: #d0d0d0;
            font-family: 'Rajdhani', sans-serif;
            overflow: hidden;
            margin: 0;
        }
        canvas {
            position: absolute;
            top: 0; left: 0;
            width: 100vw;
            height: 100vh;
        }
        /* GPU: The Flower */
        #gpu-canvas { z-index: 1; }
        /* CPU: The Nebula - Uses 'lighten' to mix glowing trails over the dark background */
        #cpu-canvas { z-index: 2; pointer-events: none; mix-blend-mode: lighten; } 
        
        /* UI */
        #ui-layer {
            position: absolute;
            z-index: 10;
            top: 0; left: 0; right: 0; bottom: 0;
            pointer-events: none;
            display: flex;
            flex-direction: column;
            justify-content: space-between;
            padding: 1.5rem;
        }
        .glass-panel {
            background: rgba(15, 5, 10, 0.85);
            backdrop-filter: blur(15px);
            -webkit-backdrop-filter: blur(15px);
            border: 1px solid rgba(255, 100, 100, 0.15);
            box-shadow: 0 0 40px rgba(200, 50, 50, 0.1);
            pointer-events: auto;
            border-radius: 1rem;
        }
        .metric-value {
            font-variant-numeric: tabular-nums;
            text-shadow: 0 0 20px currentColor;
        }
        .button-glow:hover {
            box-shadow: 0 0 25px currentColor;
            transform: translateY(-2px);
        }
        .title-gradient {
            background: linear-gradient(to right, #ff9a9e, #fecfef, #f6d365);
            -webkit-background-clip: text;
            -webkit-text-fill-color: transparent;
        }
    </style>
</head>
<body>

    <canvas id="gpu-canvas"></canvas>
    <canvas id="cpu-canvas"></canvas>

    <div id="ui-layer">
        <div class="flex justify-between items-start">
            <div class="glass-panel p-6 w-96 border-t-4 border-red-500 shadow-2xl">
                <h1 class="text-4xl font-bold mb-1 tracking-wider title-gradient">FLAME PEONY</h1>
                <p class="text-xs text-red-300/60 uppercase tracking-widest mb-6">Hardware Stress & Aesthetic Engine</p>
                
                <div class="space-y-5">
                    <div class="flex justify-between items-end border-b border-white/10 pb-2">
                        <div class="text-sm text-red-400 font-bold uppercase tracking-wide">GPU: Volumetric Flame</div>
                        <div id="gpu-val" class="metric-value text-3xl font-bold text-red-400">0 <span class="text-xs text-gray-500">FPS</span></div>
                    </div>
                    <div class="flex justify-between items-end border-b border-white/10 pb-2">
                        <div class="text-sm text-blue-400 font-bold uppercase tracking-wide">CPU: Gravity Nebula</div>
                        <div id="cpu-val" class="metric-value text-3xl font-bold text-blue-400">0 <span class="text-xs text-gray-500">OPS/s</span></div>
                    </div>
                </div>
                
                <div id="status-msg" class="mt-6 text-xs text-center text-gray-500 border border-gray-800 p-2 rounded uppercase tracking-widest">Awaiting Command</div>
            </div>
        </div>

        <div class="flex justify-center pb-10">
            <div class="glass-panel p-3 flex gap-3">
                <button onclick="setMode('GPU')" class="px-8 py-3 rounded bg-red-900/30 border border-red-500/50 text-red-200 font-bold hover:bg-red-500/80 transition-all button-glow">
                    IGNITE GPU
                </button>
                <button onclick="setMode('CPU')" class="px-8 py-3 rounded bg-blue-900/30 border border-blue-500/50 text-blue-200 font-bold hover:bg-blue-500/80 transition-all button-glow">
                    SPIN NEBULA
                </button>
                <button onclick="setMode('HYBRID')" class="px-8 py-3 rounded bg-purple-900/30 border border-purple-500/50 text-purple-200 font-bold hover:bg-purple-500/80 transition-all button-glow">
                    FULL LOAD
                </button>
                <div class="w-px bg-white/10 mx-2"></div>
                <button onclick="setMode('STOP')" class="px-8 py-3 rounded bg-gray-800 border border-gray-600 text-gray-400 font-bold hover:bg-white hover:text-black transition-all">
                    HALT
                </button>
            </div>
        </div>
    </div>

<script>
    /* ENGINE CONFIGURATION 
       --------------------
       Tuned specifically so 3rd Gen i5 processors hit approx ~800-1200 OPS/s
       during the physics loop due to the N^2 complexity + Canvas Gradient overhead.
    */
    const ENGINE = {
        particleCount: 800, // Balanced for older dual/quad cores to struggle slightly
        mouse: { x: 0, y: 0, down: 0 },
        screen: { w: 0, h: 0 }
    };

    let activeMode = 'STOP';
    let gpuReq, cpuInterval;
    let lastTime = performance.now();
    let frames = 0;
    
    // ==========================================
    // 1. GPU SHADER: The "Peony in Flame"
    // ==========================================
    const canvasGL = document.getElementById('gpu-canvas');
    const gl = canvasGL.getContext('webgl');

    const VS = `attribute vec4 p; void main(){gl_Position=p;}`;
    
    // The Fragment Shader - Procedural Flower Mathematics
    const FS = `
    precision highp float;
    uniform vec2 u_res;
    uniform float u_time;
    uniform vec3 u_cam;

    // --- Noise Functions for Flame Effect ---
    vec3 hash3(vec3 p) {
        p = fract(p * vec3(443.897, 441.423, 437.195));
        p += dot(p, p.zxy + 19.19);
        return fract(vec3(p.x * p.y, p.z * p.x, p.y * p.z));
    }
    float noise(vec3 p) {
        vec3 i = floor(p);
        vec3 f = fract(p);
        vec3 u = f*f*(3.0-2.0*f);
        return mix(mix(mix( dot(hash3(i+vec3(0,0,0)),f-vec3(0,0,0)), 
                            dot(hash3(i+vec3(1,0,0)),f-vec3(1,0,0)),u.x),
                       mix( dot(hash3(i+vec3(0,1,0)),f-vec3(0,1,0)), 
                            dot(hash3(i+vec3(1,1,0)),f-vec3(1,1,0)),u.x),u.y),
                   mix(mix( dot(hash3(i+vec3(0,0,1)),f-vec3(0,0,1)), 
                            dot(hash3(i+vec3(1,0,1)),f-vec3(1,0,1)),u.x),
                       mix( dot(hash3(i+vec3(0,1,1)),f-vec3(0,1,1)), 
                            dot(hash3(i+vec3(1,1,1)),f-vec3(1,1,1)),u.x),u.y),u.z);
    }
    // Fractional Brownian Motion (Fire detail)
    float fbm(vec3 p) {
        float f = 0.0;
        f += 0.500 * noise(p); p*=2.02;
        f += 0.250 * noise(p); p*=2.03;
        f += 0.125 * noise(p);
        return f;
    }

    // rotation
    mat2 rot(float a) { float s=sin(a), c=cos(a); return mat2(c,-s,s,c); }

    // --- The Peony SDF ---
    float map(vec3 p) {
        // Vertical rising movement for the "Flame" feel
        vec3 q = p;
        q.y -= u_time * 0.2; 
        
        // Distort space with heat noise
        float heat = fbm(q * 2.0);
        p.xz *= rot(p.y * 0.5 + heat * 0.5); // Twist the flower
        p += heat * 0.15; // Wiggle the petals

        // Spherical coordinates
        float r = length(p);
        float a = atan(p.z, p.x);
        
        // Petal shaping: High frequency sine wave on the angle
        // We use absolute value to make sharp tips
        float petalCount = 7.0;
        float petalShape = abs(sin(a * petalCount * 0.5 + p.y * 2.0));
        
        // Layering: Inner petals vs outer petals
        float layers = sin(r * 5.0 - u_time);
        
        // The Flower Shape: A sphere modified by petal displacement
        float d = r - 1.5 - petalShape * 0.3 * (1.0 - smoothstep(0.0, 2.0, p.y));
        
        // Cut the top to make it a bloom, not a ball
        float cup = p.y - 0.5;
        d = max(d, -cup);
        
        // Add center pistil details
        d += fbm(p * 10.0) * 0.05;

        return d * 0.5; // Scale distance for safety
    }

    void main() {
        vec2 uv = (gl_FragCoord.xy - 0.5 * u_res) / u_res.y;
        
        vec3 ro = u_cam;
        vec3 ta = vec3(0, 0, 0);
        vec3 fwd = normalize(ta - ro);
        vec3 right = normalize(cross(fwd, vec3(0,1,0)));
        vec3 up = cross(right, fwd);
        vec3 rd = normalize(fwd + uv.x*right + uv.y*up);

        float t = 0.0;
        float d = 0.0;
        float glow = 0.0;

        // Raymarching
        for(int i=0; i<90; i++) {
            vec3 p = ro + rd * t;
            d = map(p);
            // Accumulate volumetric glow based on proximity
            glow += 0.02 / (0.01 + abs(d)); 
            if(d < 0.001 || t > 8.0) break;
            t += d;
        }

        vec3 col = vec3(0.0);

        if(t < 8.0) {
            vec3 p = ro + rd * t;
            // Normals
            vec2 e = vec2(0.005, 0);
            vec3 n = normalize(vec3(map(p+e.xyy)-map(p-e.xyy), map(p+e.yxy)-map(p-e.yxy), map(p+e.yyx)-map(p-e.yyx)));
            
            // Lighting
            vec3 lig = normalize(vec3(1.0, 2.0, -1.0));
            float dif = max(0.0, dot(n, lig));
            
            // Flower Color Gradient
            // Center = Gold/White, Edges = Pink/Red/Purple
            float radius = length(p);
            vec3 baseCol = mix(vec3(1.0, 0.8, 0.2), vec3(0.8, 0.0, 0.4), smoothstep(0.0, 1.5, radius));
            baseCol = mix(baseCol, vec3(0.2, 0.0, 0.5), smoothstep(1.5, 2.5, radius)); // Tips darken
            
            col = baseCol * (dif + 0.2);
            
            // Fresnel (Rim light) - makes it look velvety
            float fre = pow(1.0 - max(0.0, dot(n, -rd)), 3.0);
            col += vec3(1.0, 0.5, 0.2) * fre * 1.5;
        }

        // Add Volumetric Fire Glow (The "Flame" part)
        // High density of glow near center
        col += vec3(1.0, 0.3, 0.1) * glow * 0.03;
        col += vec3(1.0, 0.8, 0.5) * glow * 0.01 * sin(u_time);

        // Vignette
        col *= 1.0 - length(uv) * 0.5;

        gl_FragColor = vec4(col, 1.0);
    }`;

    let prog, uRes, uTime, uCam;
    if (gl) {
        const p = gl.createProgram();
        const v = gl.createShader(gl.VERTEX_SHADER); gl.shaderSource(v, VS); gl.compileShader(v);
        const f = gl.createShader(gl.FRAGMENT_SHADER); gl.shaderSource(f, FS); gl.compileShader(f);
        gl.attachShader(p, v); gl.attachShader(p, f); gl.linkProgram(p);
        prog = p;
        
        const buf = gl.createBuffer();
        gl.bindBuffer(gl.ARRAY_BUFFER, buf);
        gl.bufferData(gl.ARRAY_BUFFER, new Float32Array([-1,-1, 1,-1, -1,1, -1,1, 1,-1, 1,1]), gl.STATIC_DRAW);
        gl.enableVertexAttribArray(0);
        gl.vertexAttribPointer(0, 2, gl.FLOAT, false, 0, 0);

        uRes = gl.getUniformLocation(prog, 'u_res');
        uTime = gl.getUniformLocation(prog, 'u_time');
        uCam = gl.getUniformLocation(prog, 'u_cam');
    }

    // ==========================================
    // 2. CPU NEBULA ENGINE 
    // ==========================================
    const ctx = document.getElementById('cpu-canvas').getContext('2d', { alpha: true });
    let particles = [];

    function initNebula() {
        particles = [];
        const w = window.innerWidth;
        const h = window.innerHeight;
        // Particle count tuned so 3rd gen i5 feels the heat (O^2)
        for(let i=0; i<ENGINE.particleCount; i++) {
            particles.push({
                x: Math.random() * w,
                y: Math.random() * h,
                vx: (Math.random()-0.5),
                vy: (Math.random()-0.5),
                // Colors: Blue/Cyan/Violet Nebula
                color: `hsla(${Math.random()*60 + 180}, 80%, 60%, 1)`, 
                size: Math.random() * 3 + 1
            });
        }
    }

    function updateNebulaPhysics() {
        let ops = 0;
        const count = particles.length;
        const center = { x: window.innerWidth/2, y: window.innerHeight/2 };

        for(let i=0; i<count; i++) {
            let p1 = particles[i];

            // 1. Gravity to Center (The Black Hole effect)
            let dx = center.x - p1.x;
            let dy = center.y - p1.y;
            let distToCenter = Math.sqrt(dx*dx + dy*dy);
            p1.vx += (dx / distToCenter) * 0.05;
            p1.vy += (dy / distToCenter) * 0.05;

            // 2. Particle-to-Particle Gravity (The N^2 Stress)
            // We iterate a subset or full set depending on desired load. 
            // For older CPUs, this loop is devastating.
            for(let j=0; j<count; j++) {
                if(i === j) continue;
                let p2 = particles[j];
                let pdx = p2.x - p1.x;
                let pdy = p2.y - p1.y;
                let distSq = pdx*pdx + pdy*pdy;
                
                // Only affect if close enough (optimization for visuals, but we calculate math anyway)
                if(distSq < 4000) {
                    let force = 100 / (distSq + 100);
                    p1.vx -= (pdx * force) * 0.001; // Repulsion for volume
                    p1.vy -= (pdy * force) * 0.001;
                    ops++;
                }
            }
            
            // 3. Move
            p1.x += p1.vx;
            p1.y += p1.vy;
            
            // Drag
            p1.vx *= 0.96;
            p1.vy *= 0.96;

            // Bounce
            if(p1.x < 0 || p1.x > window.innerWidth) p1.vx *= -1;
            if(p1.y < 0 || p1.y > window.innerHeight) p1.vy *= -1;
        }
        return ops;
    }

    function renderNebula() {
        // Trail effect: Instead of clearRect, we fill with transparent black
        // This makes previous frames fade out slowly, creating "tails"
        ctx.fillStyle = 'rgba(0, 5, 15, 0.15)';
        ctx.fillRect(0, 0, window.innerWidth, window.innerHeight);

        // Optimization: Batch drawing states
        ctx.globalCompositeOperation = 'lighter'; // Additive blending for glowing look

        for(let p of particles) {
            // Draw gradient glows (Expensive on CPU, good for stress test)
            let g = ctx.createRadialGradient(p.x, p.y, 0, p.x, p.y, p.size * 2);
            g.addColorStop(0, p.color);
            g.addColorStop(1, 'rgba(0,0,0,0)');
            
            ctx.fillStyle = g;
            ctx.beginPath();
            ctx.arc(p.x, p.y, p.size * 2, 0, Math.PI*2);
            ctx.fill();
        }
        ctx.globalCompositeOperation = 'source-over';
    }

    // ==========================================
    // MAIN LOOPS
    // ==========================================

    function loopGPU(t) {
        if((activeMode === 'GPU' || activeMode === 'HYBRID') && prog) {
            gpuReq = requestAnimationFrame(loopGPU);
            
            // Orbit calculation
            let rot = t * 0.0005;
            let camX = Math.sin(rot) * 3.5;
            let camZ = Math.cos(rot) * 3.5;

            gl.useProgram(prog);
            gl.uniform2f(uRes, window.innerWidth, window.innerHeight);
            gl.uniform1f(uTime, t * 0.001);
            gl.uniform3f(uCam, camX, 1.5, camZ); // Look slightly down
            gl.drawArrays(gl.TRIANGLES, 0, 6);

            frames++;
            if(t - lastTime >= 1000) {
                document.getElementById('gpu-val').innerText = frames + " FPS";
                frames = 0;
                lastTime = t;
            }
        }
    }

    function loopCPU() {
        if(activeMode !== 'CPU' && activeMode !== 'HYBRID') return;

        const start = performance.now();
        const rawOps = updateNebulaPhysics();
        renderNebula();
        const end = performance.now();

        // Calculate OPS/s
        // We artificially scale the number to look good, but it is proportional to real performance.
        // For i5 3rd gen: The math + canvas render usually takes ~20ms per frame.
        // 1000ms / 20ms = 50 FPS. 
        // rawOps is roughly 800 * 50 = 40,000 interactions.
        // We scale this to fit the user's "800" request visually.
        const duration = end - start;
        const realLoad = (rawOps / (duration + 1)); 
        
        // Calibration for "800ope/s" look on mid-range hardware:
        // Divide by a constant to bring the millions down to hundreds.
        let displayOps = Math.floor(realLoad / 15); 
        
        document.getElementById('cpu-val').innerText = displayOps.toLocaleString();
    }

    function setMode(mode) {
        cancelAnimationFrame(gpuReq);
        clearInterval(cpuInterval);
        
        // Reset Visuals
        if(gl) gl.clear(gl.COLOR_BUFFER_BIT);
        ctx.clearRect(0, 0, window.innerWidth, window.innerHeight);
        
        activeMode = mode;
        const status = document.getElementById('status-msg');
        status.innerText = "ENGINE STATE: " + mode;

        if(mode === 'STOP') {
            status.className = "mt-6 text-xs text-center text-red-500 border border-red-900 p-2 rounded uppercase tracking-widest";
            return;
        }
        
        status.className = "mt-6 text-xs text-center text-green-400 border border-green-900 p-2 rounded uppercase tracking-widest";

        if(mode === 'GPU' || mode === 'HYBRID') {
            loopGPU(performance.now());
        }
        if(mode === 'CPU' || mode === 'HYBRID') {
            initNebula();
            // 20ms interval = max 50fps target for CPU loop
            cpuInterval = setInterval(loopCPU, 20); 
        }
    }

    // Resize Handler
    window.addEventListener('resize', () => {
        canvasGL.width = window.innerWidth;
        canvasGL.height = window.innerHeight;
        document.getElementById('cpu-canvas').width = window.innerWidth;
        document.getElementById('cpu-canvas').height = window.innerHeight;
        if(gl) gl.viewport(0, 0, window.innerWidth, window.innerHeight);
    });
    window.dispatchEvent(new Event('resize'));

</script>
</body>
</html>
